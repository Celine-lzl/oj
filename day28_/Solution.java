package day28_;

import java.util.Scanner;

public class Solution {


    /**
     * d28_2 猴子分桃
     * method1:
     * 假设在开始时就有 X 个桃子，借给猴子们 4 个后，此时就一共有 X+4 个桃子。
     * 当第一只小猴子来时，它将 X+4 个桃子均分为 5 堆后，拿走 (X+4)*(1/5) 个，
     * 剩余 (X+4)*(4/5) 个桃子。在这里，有人可能会有疑问：给老猴子的那个桃子去哪里呢？
     * 其实，小猴子拿的那一部分就包括了这一个桃子，并且小猴子也没有多得桃子，它实际上得
     * 到的桃子数为  (X+4)*(1/5) - 1 = (X-1)*(1/5) ，这和在不借给它们 4 个桃子的情
     * 况下得到的数量是一样的，不过此时剩余的桃子数相较于之前多了(X+4)*(4/5) - (X-1)*(4/5) = 4 个，
     * 但这样就恰巧保证了下一只小猴子分桃时，也能刚好均分为 5 堆。由此可见，所有的小猴子都不会多得桃子，
     * 老猴子也不会少得桃子，并且每次小猴子都能刚好将桃子均分为 5 堆，而借给的那 4 个桃子每次都在剩余的
     * 那部分里，最后去除即可。
     * 第二只猴子来时，它将 (X+4)*(4/5) 个桃子均分为 5 堆后，拿走 (X+4)*(4/5)*(1/5) 个，剩余 (X+4)*(4/5)^2 个桃子。
     * 第三只猴子来时，它将 (X+4)*(4/5)^2 个桃子均分为 5 堆后，拿走 (X+4)*(4/5)^2*(1/5) 个，剩余 (X+4)*(4/5)^3 个桃子。
     * 　　.....
     * 依次类推，当第 n 只小猴子（最后一只小猴子）来时，它将 (X+4)*(4/5)^(n-1) 个桃子均分为 5 堆后，
     *  拿走 (X+4)*(4/5)^(n-1)*(1/5) 个，剩余 (X+4)*(4/5)^n 个桃子。
     *  为了满足题目最后的要求，也就是要保证最后剩余的桃子数最少且为整数，那么当 X+4 = 5^n 时，刚好满足要求，此时可得出：
     * （1）开始时的总桃子数：X = 5^n - 4
     * （2）老猴子最后能得到的桃子数：n + (X+4)*(4/5)^n - 4 = n + 4^n - 4
     * 　因为老猴子能得到的桃子主要有两个来源：一是每个小猴子都要给一个，有 n 只小猴子，就可以得到 n 个；
     *   二是最后剩余的桃子都归老猴子所有，从上面最后一次的结果来看，一共剩余了 (X+4)*(4/5)^n 个桃子，
     *   但是这里面包括我们借给它们的 4 个，实际上剩余的桃子数为 (X+4) * (4/5)^n -4 ，最后就是 n + (X+4)*(4/5)^n - 4
     *
     *  method2:
     *  第一次经过题目的处理剩余桃子数目为：4/5(X-1)=(4/5)*X-(4/5)；
     *  第二次剩余桃子个数为：4/5(4/5(X-1)-1)=((4/5)^2)*X-(4/5)^2-(4/5)；
     *  第三次剩余桃子个数为：4/5(4/5(4/5(X-1)-1)-1)=((4/5)^3)*X-(4/5)^3-(4/5)^2-(4/5)；
     * 依次类推，经过n只猴子的类似处理，剩余桃子数为：
     * 4/5(4/5(4/5(....(4/5(X-1)...)-1)-1)-1)=((4/5)^n)*X)-(4/5)^n-(4/5)^(n-1)-...-(4/5)
     * =((4/5)^n)*X)-4[1-(4/5)^n]
     * =(X+4)*(4/5)^n-4
     */
    public static void peach(String[] args){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n = sc.nextInt();
            if(n == 0){
                return;
            }
            long a = (long)Math.pow(5,n);
            long b = (long)Math.pow(4,n);
            System.out.println(a-4 + " " + (b + n -4));
        }
    }

    /**
     * d28_1 奇数位都是奇数或者偶数位都是偶数
     * 用两个指针，i指向偶数位，j指向奇数位
     * 每次与数组中最后一个数比较，如果最后一个数是偶数，就将其与i处的数交换
     * 最后一个数是奇数时同理，每次交换后i，j都+2
     */
    public void oddInOddEvenInEven(int[] arr) {
        int i = 0;
        int j = 1;
        int len = arr.length;
        while(i < len && j < len){
            if(arr[len-1] % 2 == 0){
                swap(arr,len-1,i);
                i += 2;
            }else{
                swap(arr,len-1,j);
                j += 2;
            }
        }
    }
    // 交换
    public void swap(int[] arr, int i, int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
